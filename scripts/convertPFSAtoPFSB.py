#!/usr/bin/env python3
"""
Converts a n-band PFSA file (generated by the 2D simulator) to a PFSB-compliant file.

This is useful for testing 2DDRP following the implementation of PIPE2D-668.
"""
from astropy.io import fits
from astropy.io.fits.header import Header
from astropy.io.fits.hdu.image import ImageHDU
import numpy as np
import argparse
import os
import pathlib
import glob
from typing import List


def extractRange(specification: str) -> List[int]:
    """ Expands shorthand specification of a range of visis to the full list
     eg: '123..126' to [123,124,125,126].

    Parameters
    ----------
    specification : `str`
        range of visits, in shorthand notation.

    Returns
    -------
    visits : `List` [`int`]
        expanded visits.
    """
    if (specification[0] == '^' or
        specification[0] == '.' or
        specification[-1] == '^' or
        specification[-1] == '.'):
        raise ValueError(f'Range specification {specification} isnt valid.')

    tokens = []
    start = 0
    end = 1
    while(True):
        if end >= len(specification):
            tokens.append(specification[start:end])
            break
        if specification[end] == '^':
            tokens.append(specification[start:end])
            # out.append('^')
            start = end + 1
            end = start + 1
        if specification[end: (end + 2)] == '..':
            tokens.append(specification[start:end])
            tokens.append('R')
            start = end + 2
            end = start + 1
        end += 1

    out = []
    first = None
    rangeMode = False
    for tt in tokens:
        if rangeMode:
            if first is None:
                raise ValueError('Start value for range is not set.')
            for ii in range(first, int(tt) + 1):
                out.append(ii)
            rangeMode = False
            continue
        if tt == 'R':
            rangeMode = True
            continue
        value = int(tt)
        out.append(value)
        first = value + 1

    return out


def copyCard(headerIn: Header, headerOut: Header, key: str) -> None:
    """Copies a FITS card from one header to another.

    Parameters
    ----------
    headerIn : `astropy.io.fits.Header`
        input header
    headerOut : `astropy.io.fits.Header`
        output header

    """
    if key not in headerIn:
        raise ValueError(f'key [{key}] doesnt exist in original header')
    headerOut[key] = headerIn[key]


def createImageHDU(name: str, data: np.ndarray) -> ImageHDU:
    """Creates an Image HDU instance based in the input name and data

    Parameters
    ----------
    name : `str`
        Name of HDU
    data : numpy.ndarray
        data to populate image

    Returns
    -------
    imageHDU : `astropy.io.fits.hdu.image.ImageHDU`
        populated image HDU object.
    """

    imageHDU = fits.ImageHDU(name=name, data=data)
    imageHDU.header["INHERIT"] = True
    # resetImage1.header['W_H4READ'] = 0
    imageHDU.header["W_H4GRUP"] = 1
    return imageHDU


def convert(inPFSA: str, ccdImageFile: str, outPFSB: str) -> None:
    """Converts input PFxA data to PFxB

    Parameters
    ----------
    inPFSA : `str`
        Name of input PFxA file containing header information.
    ccdImageFile : `str`
        Name of file containing actual image data to be written.
    outPFSB : `str`
        Name of output PFxB file containing reformatted information.
    """

    pfsaImageHDUIn = None
    with fits.open(inPFSA) as hdul:
        pfsaImageHDUIn = hdul[1].copy()

    expTime = pfsaImageHDUIn.header["EXPTIME"]
    # There will be 2 reads in this example, with the last read corresponding
    # to the IMAGE_2 HDU
    nRead = 2

    phdu = fits.PrimaryHDU()
    phduHeader = phdu.header
    phduHeader["W_H4FFMT"] = 3
    phduHeader["W_4FMTVR"] = 3  # FIXME: this is wrong, but fix later
    phduHeader['W_FRMTIM'] = int(expTime / nRead)
    phduHeader['W_H4NRED'] = nRead
    phduHeader["W_H4NRST"] = 1
    phduHeader["W_H4IRP"] = False
    phduHeader['W_H4GAIN'] = 1
    phduHeader["EXPTIME"] = expTime

    # Copy other other useful cards
    for cc in ['DATE-OBS', 'IMAGETYP', 'W_VISIT', 'W_PFDSGN',
               'W_AITQTH', 'W_AITNEO', 'W_AITHGA', 'W_AITXEN', 'W_AITKRY',
               'W_ENFCAZ', 'W_ENFCAY', 'W_ENFCAZ']:
        copyCard(pfsaImageHDUIn.header, phduHeader, cc)

    # Create zero-value image HDUs
    zeroArray = np.zeros((4096, 4096), dtype=np.int16)
    resetImage1 = createImageHDU(name="RESET_IMAGE_1", data=zeroArray)
    resetRef1 = createImageHDU(name="RESET_REF_1", data=zeroArray)
    image1 = createImageHDU(name="IMAGE_1", data=zeroArray)
    ref1 = createImageHDU(name="REF_1", data=zeroArray)
    ref2 = createImageHDU(name="REF_2", data=zeroArray)

    # Now construct HDU of actual data.
    # Actual image data will be taken from the corresponding postISRCCD image.
    # This is corrected for amplifier flip, bias and darks
    ccdImageHDUIn = None
    with fits.open(ccdImageFile) as hdul:
        ccdImageHDUIn = hdul[1].copy()

    # ccdImage has incorrect shape (4176, 4096). Truncate blue end.
    # note that wavelength in raw data is x-axis,
    # with lower x-values corresponding to redder end.
    data = ccdImageHDUIn.data
    dataTrunc = data[:4096, :]

    # Now need to rotate image, such that wavelength increases from right to left,
    # ie bluer (low wavelengths) corresponds to high (right) x-value
    dataRot = np.rot90(dataTrunc, k=-1)

    # Create HDU
    image2 = createImageHDU(name="IMAGE_2", data=dataRot)
    # Scale image data before writing out
    image2.scale('int32', 'minmax')

    hdulOut = fits.HDUList([phdu, resetImage1, resetRef1, image1, ref1, image2, ref2])
    hdulOut.writeto(outPFSB)


def main() -> None:
    # FIXME: move hard-coded default paths and visit to separate script
    parser = argparse.ArgumentParser()
    parser.add_argument("--inDir", type=str,
                        # default='/projects/HSC/PFS/weekly-20210819',
                        required=True)
    parser.add_argument("--ccdDir",
                        type=str,
                        # default='/scratch/hassans/weekly/weekly-w2022-40a/rerun/detrend',
                        required=True)
    parser.add_argument("--outDir", type=str, default='./out', required=False)
    parser.add_argument("--visits", type=str,
                        # default='39',
                        required=True,
                        help='comma-delimited list of visits, eg "123, 456"')
    parser.add_argument("--spectrograph", type=int, default=1, required=False)

    args = parser.parse_args()

    spectrograph = 1
    armNum = 3  # n
    armChar = 'n'

    pathlib.Path(args.outDir).mkdir(exist_ok=True)

    visits = extractRange(args.visits)
    print(f'Found visits {visits}')
    for vv in visits:
        visit = int(vv)
        suffix = f'{visit:06d}{spectrograph:1d}{armNum:1d}.fits'
        inFile = os.path.join(args.inDir, f'PFFA{suffix}')
        outFile = os.path.join(args.outDir, f'PFFB{suffix}')

        ccdFileName = f'postIsrCcd-FA{visit:06d}{armChar:1}{spectrograph:1d}.fits'
        globStr = os.path.join(args.ccdDir, '**', ccdFileName)
        files = glob.glob(globStr, recursive=True)
        if not files:
            raise ValueError(f'Cannot find file {ccdFileName} in path {args.ccdDir}')
        if len(files) != 1:
            raise ValueError(f'Multiple files matching {ccdFileName} in path {args.ccdDir}: {files}')

        ccdImagePath = files[0]
        print(f'Converting {inFile} to {outFile} ..')
        convert(inFile, ccdImagePath, outFile)


if __name__ == "__main__":
    main()
