#!/usr/bin/env python3
"""
Converts a n-band PFSA file (generated by the 2D simulator) to a PFSB-compliant file.

This is useful for testing 2DDRP following the implementation of PIPE2D-668.
"""
from astropy.io import fits
import numpy as np
import argparse
import os
import pathlib
import glob


def extractRange(specification):

    if (specification[0] == '^'
        or specification[0] == '.'
        or specification[-1] == '^'
        or specification[-1] == '.'):
        raise ValueError(f'Range specification {specification} isnt valid.')

    tokens = []
    start = 0
    end = 1
    while(True):
        if end >= len(specification):
            tokens.append(specification[start:end])
            break
        if specification[end] == '^':
            tokens.append(specification[start:end])
            # out.append('^')
            start = end + 1
            end = start + 1
        if specification[end: (end + 2)] == '..':
            tokens.append(specification[start:end])
            tokens.append('R')
            start = end + 2
            end = start + 1
        end += 1

    out = []
    first = None
    rangeMode = False
    for tt in tokens:
        if rangeMode:
            if first is None:
                raise ValueError('Start value for rang is not set.')
            for ii in range(first, int(tt)):
                out.append(ii)
            rangeMode = False
            continue
        if tt == 'R':
            rangeMode = True
            continue
        value = int(tt)
        out.append(value)
        first = value + 1

    return out


def copyCard(headerIn, headerOut, key):
    if key not in headerIn:
        raise ValueError(f'key [{key}] doesnt exist in original header')
    headerOut[key] = headerIn[key]


def createImageHDU(name, data):
    imageHDU = fits.ImageHDU(name=name, data=data)
    imageHDU.header["INHERIT"] = True
    # resetImage1.header['W_H4READ'] = 0
    imageHDU.header["W_H4GRUP"] = 1
    return imageHDU


def convert(inPFSA, ccdImageFile, outPFSB):

    pfsaImageHDUIn = None
    with fits.open(inPFSA) as hdul:
        pfsaImageHDUIn = hdul[1].copy()

    expTime = pfsaImageHDUIn.header["EXPTIME"]
    # There will be 2 reads in this example, with the last read corresponding
    # to the IMAGE_2 HDU
    nRead = 2

    phdu = fits.PrimaryHDU()
    phduHeader = phdu.header
    phduHeader["W_H4FFMT"] = 3
    phduHeader["W_4FMTVR"] = 3  # FIXME: this is wrong, but fix later
    phduHeader['W_FRMTIM'] = int(expTime / nRead)
    phduHeader['W_H4NRED'] = nRead
    phduHeader["W_H4NRST"] = 1
    phduHeader["W_H4IRP"] = False
    phduHeader['W_H4GAIN'] = 1
    phduHeader["EXPTIME"] = expTime

    # Copy other other useful cards
    for cc in ['DATE-OBS', 'IMAGETYP', 'W_VISIT', 'W_PFDSGN',
               'W_AITQTH', 'W_AITNEO', 'W_AITHGA', 'W_AITXEN', 'W_AITKRY',
               'W_ENFCAZ', 'W_ENFCAY', 'W_ENFCAZ']:
        copyCard(pfsaImageHDUIn.header, phduHeader, cc)

    zeroArray = np.zeros((4096, 4096), dtype=np.int16)
    resetImage1 = createImageHDU(name="RESET_IMAGE_1", data=zeroArray)
    resetRef1 = createImageHDU(name="RESET_REF_1", data=zeroArray)
    image1 = createImageHDU(name="IMAGE_1", data=zeroArray)
    ref1 = createImageHDU(name="REF_1", data=zeroArray)

    # Actual image data will be taken from the corresponding postISRCCD image.
    # This is corrected for amplifier flip, bias and darks
    ccdImageHDUIn = None
    with fits.open(ccdImageFile) as hdul:
        ccdImageHDUIn = hdul[1].copy()

    # ccdImage has incorrect shape (4176, 4096). Truncate blue end.
    # note that wavelength in raw data is x-axis,
    # with lower x-values corresponding to redder end.
    data = ccdImageHDUIn.data
    dataTrunc = data[:4096, :]

    # Now need to rotate image, such that wavelength increases from right to left,
    # ie bluer (low wavelengths) corresponds to high (right) x-value
    dataRot = np.rot90(dataTrunc)

    # Convert to int16
    dataInt = dataRot.astype(np.int16)

    # Write out HDU
    image2 = createImageHDU(name="IMAGE_2", data=dataInt)

    # And last zero array
    ref2 = createImageHDU(name="REF_2", data=zeroArray)

    hdulOut = fits.HDUList([phdu, resetImage1, resetRef1, image1, ref1, image2, ref2])
    hdulOut.writeto(outPFSB)


def main():
    # FIXME: move hard-coded default paths and visit to separate script
    parser = argparse.ArgumentParser()
    parser.add_argument("--inDir", type=str,
                        # default='/projects/HSC/PFS/weekly-20210819',
                        required=True)
    parser.add_argument("--ccdDir",
                        type=str,
                        # default='/scratch/hassans/weekly/weekly-w2022-40a/rerun/detrend',
                        required=True)
    parser.add_argument("--outDir", type=str, default='./out', required=False)
    parser.add_argument("--visits", type=str,
                        # default='39',
                        required=True,
                        help='comma-delimited list of visits, eg "123, 456"')
    parser.add_argument("--spectrograph", type=int, default=1, required=False)

    args = parser.parse_args()

    spectrograph = 1
    armNum = 3  # n
    armChar = 'n'

    pathlib.Path(args.outDir).mkdir(exist_ok=True)

    visits = extractRange(args.visits)
    print(f'Found visits {visits}')
    for vv in visits:
        visit = int(vv)
        suffix = f'{visit:06d}{spectrograph:1d}{armNum:1d}.fits'
        inFile = os.path.join(args.inDir, f'PFFA{suffix}')
        outFile = os.path.join(args.outDir, f'PFFB{suffix}')

        ccdFileName = f'postIsrCcd-FA{visit:06d}{armChar:1}{spectrograph:1d}.fits'
        globStr = os.path.join(args.ccdDir, '**', ccdFileName)
        files = glob.glob(globStr, recursive=True)
        if not files:
            raise ValueError(f'Cannot find file {ccdFileName} in path {args.ccdDir}')
        if len(files) != 1:
            raise ValueError(f'Multiple files matching {ccdFileName} in path {args.ccdDir}: {files}')

        ccdImagePath = files[0]
        print(f'Converting {inFile} to {outFile} ..')
        convert(inFile, ccdImagePath, outFile)


if __name__ == "__main__":
    main()
